# Redis 분산락 구조 요약
## 단계	동작 내용
    setIfAbsent 시도	"msg:lock:{phone}" key가 Redis에 있는지 확인
    없다면 → 메시지 Kafka로 전송 & expire 1분 설정
    있다면 → 이미 전송된 사용자이므로 전송 생략

## 왜 Redis를 써야 할까?
    Spring Boot 인스턴스가 여러 개 떠 있을 수 있음 (e.g. 도커 컨테이너 여러 개)
    이 경우 동시에 같은 사용자에게 중복 메시지를 보낼 수 있음
    Redis는 중앙 저장소라서 → 모든 인스턴스에서 락 공유 가능
    따라서 동시성 제어와 중복 방지 역할을 완벽하게 해줌

## 예시 흐름 (전화번호 01012345678)
    Kafka 전송 전 msg:lock:01012345678 존재 여부 확인
    없다면:
        Redis에 저장 (setIfAbsent)
        TTL 1분 설정 (expire)
    Kafka 전송
    있다면:
        이미 보냈으므로 무시 (중복 전송 방지)

## Kafka 토픽 분리 개념 (연령대별 메시지 처리용)

### 개요
    Kafka는 메시지를 전송/수신할 수 있는 **중앙 메시지 허브** 역할을 함.  
    그 중심 단위는 **토픽(topic)** 이며, Producer는 이 토픽으로 메시지를 보내고, 
    Consumer는 해당 토픽을 구독하여 메시지를 처리함.
    이번 시스템에서는 연령대별 메시지를 독립적으로 처리하기 위해 Kafka 토픽을 연령대별로 분리함.

### 연령대별 Kafka 토픽 분리 구조

| 연령대        | Kafka 토픽            | Consumer 클래스        |
|------------|------------------------|-------------------------|
| 20대        | `message-topic-20s`    | `MessageConsumer20s`    |
| 30대        | `message-topic-30s`    | `MessageConsumer30s`    |
| (추가가능) 40대 | `message-topic-40s` | `MessageConsumer40s` |

→ Producer는 메시지를 전송할 때 사용자 연령대에 따라 토픽을 선택함  
→ Consumer는 각각의 토픽만 구독함으로써 연령대별 처리 분리가 가능해짐

---

##  왜 토픽을 나누는가?

- **RateLimit 분리 처리용**  
  → 카카오톡/SMS API는 분당 호출 제한이 있음  
  → 연령대별로 나누면 개별 제한량을 초과하지 않도록 관리 가능

- **장애 격리**  
  → 30대 토픽에서 오류 발생 시, 20대 토픽에는 영향 없음

- **비즈니스 로직 분리 용이**  
  → 연령대별로 메시지 포맷, 대상, 방식이 다를 경우 처리 코드를 분리할 수 있음

- **확장성 확보**  
  → 40대, 50대 추가 시 토픽 + Consumer만 추가하면 구조 유지 가능

---

## ✅ Kafka 토픽 vs 파티션 차이

| 항목     | 의미 |
|----------|------|
| Topic    | 메시지를 기능별/속성별로 구분하는 논리적 단위 |
| Partition | 하나의 토픽을 물리적으로 병렬처리하기 위한 단위 |

예:
```plaintext
Topic: message-topic-20s
 ├─ Partition 0
 ├─ Partition 1
 └─ Partition 2
